/* !
 * perfect-scrollbar v1.3.0
 * (c) 2017 Hyunje Jun
 * @license MIT
 */
!(function (t, e) {
    typeof exports == 'object' && typeof module != 'undefined' ? module.exports = e() : typeof define == 'function' && define.amd ? define(e) : t.PerfectScrollbar = e();
})(this, function () {
    function t(t) {
        return getComputedStyle(t);
    } function e(t, e) {
        for (const i in e) {
            let r = e[i];

            typeof r == 'number' && (r += 'px'), t.style[i] = r;
        } return t;
    } function i(t) {
        const e = document.createElement('div');

        return e.className = t, e;
    } function r(t, e) {
        if (!v) {
            throw new Error('No element matching method supported');
        } return v.call(t, e);
    } function l(t) {
        t.remove ? t.remove() : t.parentNode && t.parentNode.removeChild(t);
    } function n(t, e) {
        return Array.prototype.filter.call(t.children, function (t) {
            return r(t, e);
        });
    } function o(t, e) {
        const i = t.element.classList; const r = m.state.scrolling(e);

        i.contains(r) ? clearTimeout(Y[e]) : i.add(r);
    } function s(t, e) {
        Y[e] = setTimeout(function () {
            return t.isAlive && t.element.classList.remove(m.state.scrolling(e));
        }, t.settings.scrollingThreshold);
    } function a(t, e) {
        o(t, e), s(t, e);
    } function c(t) {
        if (typeof window.CustomEvent == 'function') {
            return new CustomEvent(t);
        } const e = document.createEvent('CustomEvent');

        return e.initCustomEvent(t, !1, !1, void 0), e;
    } function h(t, e, i, r, l) {
        const n = i[0]; const o = i[1]; const s = i[2]; const h = i[3]; const u = i[4]; const d = i[5];

        void 0 === r && (r = !0), void 0 === l && (l = !1); const f = t.element;

        t.reach[h] = null, f[s] < 1 && (t.reach[h] = 'start'), f[s] > t[n] - t[o] - 1 && (t.reach[h] = 'end'), e && (f.dispatchEvent(c('ps-scroll-' + h)), e < 0 ? f.dispatchEvent(c('ps-scroll-' + u)) : e > 0 && f.dispatchEvent(c('ps-scroll-' + d)), r && a(t, h)), t.reach[h] && (e || l) && f.dispatchEvent(c('ps-' + h + '-reach-' + t.reach[h]));
    } function u(t) {
        return parseInt(t, 10)||0;
    } function d(t) {
        return r(t, 'input,[contenteditable]') || r(t, 'select,[contenteditable]') || r(t, 'textarea,[contenteditable]') || r(t, 'button,[contenteditable]');
    } function f(e) {
        const i = t(e);

        return u(i.width) + u(i.paddingLeft) + u(i.paddingRight) + u(i.borderLeftWidth) + u(i.borderRightWidth);
    } function p(t, e) {
        return t.settings.minScrollbarLength && (e = Math.max(e, t.settings.minScrollbarLength)), t.settings.maxScrollbarLength && (e = Math.min(e, t.settings.maxScrollbarLength)), e;
    } function b(t, i) {
        const r = {width: i.railXWidth};

        i.isRtl ? r.left = i.negativeScrollAdjustment + t.scrollLeft + i.containerWidth - i.contentWidth : r.left = t.scrollLeft, i.isScrollbarXUsingBottom ? r.bottom = i.scrollbarXBottom - t.scrollTop : r.top = i.scrollbarXTop + t.scrollTop, e(i.scrollbarXRail, r); const l = {top: t.scrollTop, height: i.railYHeight};

        i.isScrollbarYUsingRight ? i.isRtl ? l.right = i.contentWidth - (i.negativeScrollAdjustment + t.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth : l.right = i.scrollbarYRight - t.scrollLeft : i.isRtl ? l.left = i.negativeScrollAdjustment + t.scrollLeft + 2 * i.containerWidth - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth : l.left = i.scrollbarYLeft + t.scrollLeft, e(i.scrollbarYRail, l), e(i.scrollbarX, {left: i.scrollbarXLeft, width: i.scrollbarXWidth - i.railBorderXWidth}), e(i.scrollbarY, {top: i.scrollbarYTop, height: i.scrollbarYHeight - i.railBorderYWidth});
    } function g(t, e) {
        function i(e) {
            p[d] = b + v * (e[a] - g), o(t, f), T(t), e.stopPropagation(), e.preventDefault();
        } function r() {
            s(t, f), t.event.unbind(t.ownerDocument, 'mousemove', i);
        } var l = e[0], n = e[1], a = e[2], c = e[3], h = e[4], u = e[5], d = e[6], f = e[7], p = t.element, b = null, g = null, v = null;

        t.event.bind(t[h], 'mousedown', function (e) {
            b = p[d], g = e[a], v = (t[n] - t[l]) / (t[c] - t[u]), t.event.bind(t.ownerDocument, 'mousemove', i), t.event.once(t.ownerDocument, 'mouseup', r), e.stopPropagation(), e.preventDefault();
        });
    } var v = typeof Element != 'undefined' && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.msMatchesSelector), m = {main: 'ps', element: {thumb(t) {
            return 'ps__thumb-' + t;
        }, rail(t) {
            return 'ps__rail-' + t;
        }, consuming: 'ps__child--consume'}, state: {focus: 'ps--focus', active(t) {
            return 'ps--active-' + t;
        }, scrolling(t) {
            return 'ps--scrolling-' + t;
        }}}, Y = {x: null, y: null}, X = function (t) {
            this.element = t, this.handlers = {};
        }, w = {isEmpty: {configurable: !0}};

    X.prototype.bind = function (t, e) {
        void 0 === this.handlers[t] && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1);
    }, X.prototype.unbind = function (t, e) {
        const i = this;

        this.handlers[t] = this.handlers[t].filter(function (r) {
            return !(!e || r === e) || (i.element.removeEventListener(t, r, !1), !1);
        });
    }, X.prototype.unbindAll = function () {
        const t = this;

        for (const e in t.handlers) {
            t.unbind(e);
        }
    }, w.isEmpty.get = function () {
        const t = this;

        return Object.keys(this.handlers).every(function (e) {
            return t.handlers[e].length === 0;
        });
    }, Object.defineProperties(X.prototype, w); const y = function () {
        this.eventElements = [];
    };

    y.prototype.eventElement = function (t) {
        let e = this.eventElements.filter(function (e) {
            return e.element === t;
        })[0];

        return e || (e = new X(t), this.eventElements.push(e)), e;
    }, y.prototype.bind = function (t, e, i) {
        this.eventElement(t).bind(e, i);
    }, y.prototype.unbind = function (t, e, i) {
        const r = this.eventElement(t);

        r.unbind(e, i), r.isEmpty && this.eventElements.splice(this.eventElements.indexOf(r), 1);
    }, y.prototype.unbindAll = function () {
        this.eventElements.forEach(function (t) {
            return t.unbindAll();
        }), this.eventElements = [];
    }, y.prototype.once = function (t, e, i) {
        var r = this.eventElement(t), l = function (t) {
            r.unbind(e, l), i(t);
        };

        r.bind(e, l);
    }; var W = function (t, e, i, r, l) {
            void 0 === r && (r = !0), void 0 === l && (l = !1); let n;

            if (e === 'top') {
                n = ['contentHeight', 'containerHeight', 'scrollTop', 'y', 'up', 'down'];
            } else {
                if (e !== 'left') {
                    throw new Error('A proper axis should be provided');
                } n = ['contentWidth', 'containerWidth', 'scrollLeft', 'x', 'left', 'right'];
            }h(t, i, n, r, l);
        }, L = {isWebKit: typeof document != 'undefined' && 'WebkitAppearance' in document.documentElement.style, supportsTouch: typeof window != 'undefined' && ('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch), supportsIePointer: typeof navigator != 'undefined' && navigator.msMaxTouchPoints, isChrome: typeof navigator != 'undefined' && /chrome/i.test(navigator && navigator.userAgent)}, T = function (t) {
            const e = t.element;

            t.containerWidth = e.clientWidth, t.containerHeight = e.clientHeight, t.contentWidth = e.scrollWidth, t.contentHeight = e.scrollHeight, e.contains(t.scrollbarXRail) || (n(e, m.element.rail('x')).forEach(function (t) {
                return l(t);
            }), e.appendChild(t.scrollbarXRail)), e.contains(t.scrollbarYRail) || (n(e, m.element.rail('y')).forEach(function (t) {
                return l(t);
            }), e.appendChild(t.scrollbarYRail)), !t.settings.suppressScrollX && t.containerWidth + t.settings.scrollXMarginOffset < t.contentWidth ? (t.scrollbarXActive = !0, t.railXWidth = t.containerWidth - t.railXMarginWidth, t.railXRatio = t.containerWidth / t.railXWidth, t.scrollbarXWidth = p(t, u(t.railXWidth * t.containerWidth / t.contentWidth)), t.scrollbarXLeft = u((t.negativeScrollAdjustment + e.scrollLeft) * (t.railXWidth - t.scrollbarXWidth) / (t.contentWidth - t.containerWidth))) : t.scrollbarXActive = !1, !t.settings.suppressScrollY && t.containerHeight + t.settings.scrollYMarginOffset < t.contentHeight ? (t.scrollbarYActive = !0, t.railYHeight = t.containerHeight - t.railYMarginHeight, t.railYRatio = t.containerHeight / t.railYHeight, t.scrollbarYHeight = p(t, u(t.railYHeight * t.containerHeight / t.contentHeight)), t.scrollbarYTop = u(e.scrollTop * (t.railYHeight - t.scrollbarYHeight) / (t.contentHeight - t.containerHeight))) : t.scrollbarYActive = !1, t.scrollbarXLeft >= t.railXWidth - t.scrollbarXWidth && (t.scrollbarXLeft = t.railXWidth - t.scrollbarXWidth), t.scrollbarYTop >= t.railYHeight - t.scrollbarYHeight && (t.scrollbarYTop = t.railYHeight - t.scrollbarYHeight), b(e, t), t.scrollbarXActive ? e.classList.add(m.state.active('x')) : (e.classList.remove(m.state.active('x')), t.scrollbarXWidth = 0, t.scrollbarXLeft = 0, e.scrollLeft = 0), t.scrollbarYActive ? e.classList.add(m.state.active('y')) : (e.classList.remove(m.state.active('y')), t.scrollbarYHeight = 0, t.scrollbarYTop = 0, e.scrollTop = 0);
        }, R = {'click-rail'(t) {
            t.event.bind(t.scrollbarY, 'mousedown', function (t) {
                return t.stopPropagation();
            }), t.event.bind(t.scrollbarYRail, 'mousedown', function (e) {
                const i = e.pageY - window.pageYOffset - t.scrollbarYRail.getBoundingClientRect().top > t.scrollbarYTop ? 1 : -1;

                t.element.scrollTop += i * t.containerHeight, T(t), e.stopPropagation();
            }), t.event.bind(t.scrollbarX, 'mousedown', function (t) {
                return t.stopPropagation();
            }), t.event.bind(t.scrollbarXRail, 'mousedown', function (e) {
                const i = e.pageX - window.pageXOffset - t.scrollbarXRail.getBoundingClientRect().left > t.scrollbarXLeft ? 1 : -1;

                t.element.scrollLeft += i * t.containerWidth, T(t), e.stopPropagation();
            });
        }, 'drag-thumb'(t) {
            g(t, ['containerWidth', 'contentWidth', 'pageX', 'railXWidth', 'scrollbarX', 'scrollbarXWidth', 'scrollLeft', 'x']), g(t, ['containerHeight', 'contentHeight', 'pageY', 'railYHeight', 'scrollbarY', 'scrollbarYHeight', 'scrollTop', 'y']);
        }, keyboard(t) {
            function e(e, r) {
                const l = i.scrollTop;

                if (e === 0) {
                    if (!t.scrollbarYActive) {
                        return !1;
                    } if (l === 0 && r > 0 || l >= t.contentHeight - t.containerHeight && r < 0) {
                        return !t.settings.wheelPropagation;
                    }
                } const n = i.scrollLeft;

                if (r === 0) {
                    if (!t.scrollbarXActive) {
                        return !1;
                    } if (n === 0 && e < 0 || n >= t.contentWidth - t.containerWidth && e > 0) {
                        return !t.settings.wheelPropagation;
                    }
                } return !0;
            } var i = t.element, l = function () {
                    return r(i, ':hover');
                }, n = function () {
                    return r(t.scrollbarX, ':focus') || r(t.scrollbarY, ':focus');
                };

            t.event.bind(t.ownerDocument, 'keydown', function (r) {
                if (!(r.isDefaultPrevented && r.isDefaultPrevented() || r.defaultPrevented) && (l() || n())) {
                    let o = document.activeElement ? document.activeElement : t.ownerDocument.activeElement;

                    if (o) {
                        if (o.tagName === 'IFRAME') {
                            o = o.contentDocument.activeElement;
                        } else {
                            while (o.shadowRoot) {
                                o = o.shadowRoot.activeElement;
                            }
                        } if (d(o)) {
                            return;
                        }
                    } let a = 0; let s = 0;

                    switch (r.which) {
                        case 37:s = r.metaKey ? -t.contentWidth : r.altKey ? -t.containerWidth : -30; break; case 38:a = r.metaKey ? t.contentHeight : r.altKey ? t.containerHeight : 30; break; case 39:s = r.metaKey ? t.contentWidth : r.altKey ? t.containerWidth : 30; break; case 40:a = r.metaKey ? -t.contentHeight : r.altKey ? -t.containerHeight : -30; break; case 32:a = r.shiftKey ? t.containerHeight : -t.containerHeight; break; case 33:a = t.containerHeight; break; case 34:a = -t.containerHeight; break; case 36:a = t.contentHeight; break; case 35:a = -t.contentHeight; break; default:return;
                    }t.settings.suppressScrollX && s !== 0 || t.settings.suppressScrollY && a !== 0 || (i.scrollTop -= a, i.scrollLeft += s, T(t), e(s, a) && r.preventDefault());
                }
            });
        }, wheel(e) {
            function i(t, i) {
                const r = o.scrollTop === 0; const l = o.scrollTop + o.offsetHeight === o.scrollHeight; const n = o.scrollLeft === 0; const s = o.scrollLeft + o.offsetWidth === o.offsetWidth;

                return !(Math.abs(i) > Math.abs(t) ? r || l : n || s) || !e.settings.wheelPropagation;
            } function r(t) {
                let e = t.deltaX; let i = -1 * t.deltaY;

                return void 0 !== e && void 0 !== i || (e = -1 * t.wheelDeltaX / 6, i = t.wheelDeltaY / 6), t.deltaMode && t.deltaMode === 1 && (e *= 10, i *= 10), e !== e && i !== i && (e = 0, i = t.wheelDelta), t.shiftKey ? [-i, -e] : [e, i];
            } function l(e, i, r) {
                if (!L.isWebKit && o.querySelector('select:focus')) {
                    return !0;
                } if (!o.contains(e)) {
                    return !1;
                } for (let l = e; l && l !== o;) {
                    if (l.classList.contains(m.element.consuming)) {
                        return !0;
                    } const n = t(l);

                    if ([n.overflow, n.overflowX, n.overflowY].join('').match(/(scrol{2}|auto)/)) {
                        const s = l.scrollHeight - l.clientHeight;

                        if (s > 0 && !(l.scrollTop === 0 && r > 0 || l.scrollTop === s && r < 0)) {
                            return !0;
                        } const a = l.scrollLeft - l.clientWidth;

                        if (a > 0 && !(l.scrollLeft === 0 && i < 0 || l.scrollLeft === a && i > 0)) {
                            return !0;
                        }
                    }l = l.parentNode;
                } return !1;
            } function n(t) {
                const n = r(t); const s = n[0]; const a = n[1];

                if (!l(t.target, s, a)) {
                    let c = !1;

                    e.settings.useBothWheelAxes ? e.scrollbarYActive && !e.scrollbarXActive ? (a ? o.scrollTop -= a * e.settings.wheelSpeed : o.scrollTop += s * e.settings.wheelSpeed, c = !0) : e.scrollbarXActive && !e.scrollbarYActive && (s ? o.scrollLeft += s * e.settings.wheelSpeed : o.scrollLeft -= a * e.settings.wheelSpeed, c = !0) : (o.scrollTop -= a * e.settings.wheelSpeed, o.scrollLeft += s * e.settings.wheelSpeed), T(e), (c = c || i(s, a)) && !t.ctrlKey && (t.stopPropagation(), t.preventDefault());
                }
            } var o = e.element;

            void 0 !== window.onwheel ? e.event.bind(o, 'wheel', n) : void 0 !== window.onmousewheel && e.event.bind(o, 'mousewheel', n);
        }, touch(e) {
            function i(t, i) {
                const r = h.scrollTop; const l = h.scrollLeft; const n = Math.abs(t); const o = Math.abs(i);

                if (o > n) {
                    if (i < 0 && r === e.contentHeight - e.containerHeight || i > 0 && r === 0) {
                        return window.scrollY === 0 && i > 0 && L.isChrome;
                    }
                } else if (n > o && (t < 0 && l === e.contentWidth - e.containerWidth || t > 0 && l === 0)) {
                    return !0;
                } return !0;
            } function r(t, i) {
                h.scrollTop -= i, h.scrollLeft -= t, T(e);
            } function l(t) {
                return t.targetTouches ? t.targetTouches[0] : t;
            } function n(t) {
                return !(t.pointerType && t.pointerType === 'pen' && t.buttons === 0 || (!t.targetTouches || t.targetTouches.length !== 1) && (!t.pointerType || t.pointerType === 'mouse' || t.pointerType === t.MSPOINTER_TYPE_MOUSE));
            } function o(t) {
                if (n(t)) {
                    const e = l(t);

                    u.pageX = e.pageX, u.pageY = e.pageY, d = (new Date()).getTime(), p !== null && clearInterval(p);
                }
            } function s(e, i, r) {
                if (!h.contains(e)) {
                    return !1;
                } for (let l = e; l && l !== h;) {
                    if (l.classList.contains(m.element.consuming)) {
                        return !0;
                    } const n = t(l);

                    if ([n.overflow, n.overflowX, n.overflowY].join('').match(/(scrol{2}|auto)/)) {
                        const o = l.scrollHeight - l.clientHeight;

                        if (o > 0 && !(l.scrollTop === 0 && r > 0 || l.scrollTop === o && r < 0)) {
                            return !0;
                        } const s = l.scrollLeft - l.clientWidth;

                        if (s > 0 && !(l.scrollLeft === 0 && i < 0 || l.scrollLeft === s && i > 0)) {
                            return !0;
                        }
                    }l = l.parentNode;
                } return !1;
            } function a(t) {
                if (n(t)) {
                    const e = l(t); const o = {pageX: e.pageX, pageY: e.pageY}; const a = o.pageX - u.pageX; const c = o.pageY - u.pageY;

                    if (s(t.target, a, c)) {
                        return;
                    } r(a, c), u = o; const h = (new Date()).getTime(); const p = h - d;

                    p > 0 && (f.x = a / p, f.y = c / p, d = h), i(a, c) && t.preventDefault();
                }
            } function c() {
                e.settings.swipeEasing && (clearInterval(p), p = setInterval(function () {
                    e.isInitialized ? clearInterval(p) : f.x || f.y ? Math.abs(f.x) < 0.01 && Math.abs(f.y) < 0.01 ? clearInterval(p) : (r(30 * f.x, 30 * f.y), f.x *= 0.8, f.y *= 0.8) : clearInterval(p);
                }, 10));
            } if (L.supportsTouch || L.supportsIePointer) {
                var h = e.element, u = {}, d = 0, f = {}, p = null;

                L.supportsTouch ? (e.event.bind(h, 'touchstart', o), e.event.bind(h, 'touchmove', a), e.event.bind(h, 'touchend', c)) : L.supportsIePointer && (window.PointerEvent ? (e.event.bind(h, 'pointerdown', o), e.event.bind(h, 'pointermove', a), e.event.bind(h, 'pointerup', c)) : window.MSPointerEvent && (e.event.bind(h, 'MSPointerDown', o), e.event.bind(h, 'MSPointerMove', a), e.event.bind(h, 'MSPointerUp', c)));
            }
        }}, H = function (r, l) {
            const n = this;

            if (void 0 === l && (l = {}), typeof r == 'string' && (r = document.querySelector(r)), !r || !r.nodeName) {
                throw new Error('no element is specified to initialize PerfectScrollbar');
            } this.element = r, r.classList.add(m.main), this.settings = {handlers: ['click-rail', 'drag-thumb', 'keyboard', 'wheel', 'touch'], maxScrollbarLength: null, minScrollbarLength: null, scrollingThreshold: 1e3, scrollXMarginOffset: 0, scrollYMarginOffset: 0, suppressScrollX: !1, suppressScrollY: !1, swipeEasing: !0, useBothWheelAxes: !1, wheelPropagation: !1, wheelSpeed: 1}; for (const o in l) {
                n.settings[o] = l[o];
            } this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null; const s = function () {
                return r.classList.add(m.state.focus);
            }; const a = function () {
                return r.classList.remove(m.state.focus);
            };

            this.isRtl = t(r).direction === 'rtl', this.isNegativeScroll = (function () {
                const t = r.scrollLeft; let e = null;

                return r.scrollLeft = -1, e = r.scrollLeft < 0, r.scrollLeft = t, e;
            })(), this.negativeScrollAdjustment = this.isNegativeScroll ? r.scrollWidth - r.clientWidth : 0, this.event = new y(), this.ownerDocument = r.ownerDocument || document, this.scrollbarXRail = i(m.element.rail('x')), r.appendChild(this.scrollbarXRail), this.scrollbarX = i(m.element.thumb('x')), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute('tabindex', 0), this.event.bind(this.scrollbarX, 'focus', s), this.event.bind(this.scrollbarX, 'blur', a), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null; const c = t(this.scrollbarXRail);

            this.scrollbarXBottom = parseInt(c.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = u(c.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = u(c.borderLeftWidth) + u(c.borderRightWidth), e(this.scrollbarXRail, {display: 'block'}), this.railXMarginWidth = u(c.marginLeft) + u(c.marginRight), e(this.scrollbarXRail, {display: ''}), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = i(m.element.rail('y')), r.appendChild(this.scrollbarYRail), this.scrollbarY = i(m.element.thumb('y')), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute('tabindex', 0), this.event.bind(this.scrollbarY, 'focus', s), this.event.bind(this.scrollbarY, 'blur', a), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null; const h = t(this.scrollbarYRail);

            this.scrollbarYRight = parseInt(h.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = u(h.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? f(this.scrollbarY) : null, this.railBorderYWidth = u(h.borderTopWidth) + u(h.borderBottomWidth), e(this.scrollbarYRail, {display: 'block'}), this.railYMarginHeight = u(h.marginTop) + u(h.marginBottom), e(this.scrollbarYRail, {display: ''}), this.railYHeight = null, this.railYRatio = null, this.reach = {x: r.scrollLeft <= 0 ? 'start' : r.scrollLeft >= this.contentWidth - this.containerWidth ? 'end' : null, y: r.scrollTop <= 0 ? 'start' : r.scrollTop >= this.contentHeight - this.containerHeight ? 'end' : null}, this.isAlive = !0, this.settings.handlers.forEach(function (t) {
                return R[t](n);
            }), this.lastScrollTop = r.scrollTop, this.lastScrollLeft = r.scrollLeft, this.event.bind(this.element, 'scroll', function (t) {
                return n.onScroll(t);
            }), T(this);
        };

    return H.prototype.update = function () {
        this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, e(this.scrollbarXRail, {display: 'block'}), e(this.scrollbarYRail, {display: 'block'}), this.railXMarginWidth = u(t(this.scrollbarXRail).marginLeft) + u(t(this.scrollbarXRail).marginRight), this.railYMarginHeight = u(t(this.scrollbarYRail).marginTop) + u(t(this.scrollbarYRail).marginBottom), e(this.scrollbarXRail, {display: 'none'}), e(this.scrollbarYRail, {display: 'none'}), T(this), W(this, 'top', 0, !1, !0), W(this, 'left', 0, !1, !0), e(this.scrollbarXRail, {display: ''}), e(this.scrollbarYRail, {display: ''}));
    }, H.prototype.onScroll = function (t) {
        this.isAlive && (T(this), W(this, 'top', this.element.scrollTop - this.lastScrollTop), W(this, 'left', this.element.scrollLeft - this.lastScrollLeft), this.lastScrollTop = this.element.scrollTop, this.lastScrollLeft = this.element.scrollLeft);
    }, H.prototype.destroy = function () {
        this.isAlive && (this.event.unbindAll(), l(this.scrollbarX), l(this.scrollbarY), l(this.scrollbarXRail), l(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);
    }, H.prototype.removePsClasses = function () {
        this.element.className = this.element.className.split(' ').filter(function (t) {
            return !t.match(/^ps([-_].+|)$/);
        }).join(' ');
    }, H;
});
